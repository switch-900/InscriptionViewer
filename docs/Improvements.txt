import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { Download, ZoomIn, ZoomOut, RotateCw, Maximize2, Copy, Expand, Minimize, Play, Pause, VolumeX, Volume2, SkipBack, SkipForward, Eye, EyeOff, ExternalLink, RefreshCw, Loader2, AlertCircle, Move3D, X } from 'lucide-react';
import * as THREE from 'three';

// =================== UTILITY TYPES AND INTERFACES ===================

interface ContentInfo {
  mimeType: string;
  detectedType: 'text' | 'image' | 'audio' | 'video' | 'html' | 'json' | 'svg' | '3d' | 'binary' | 'unknown';
  renderStrategy: 'native' | 'iframe' | 'unsupported';
  fileExtension?: string;
  encoding?: string;
  isInlineable: boolean;
}

interface ContentAnalysis {
  contentInfo: ContentInfo;
  preview?: string;
  error?: string;
}

interface InscriptionData {
  id: string;
  number?: number | string;
  contentUrl?: string;
  contentType?: string;
}

interface LoadedContent {
  url: string;
  blob: Blob;
  text?: string;
  analysis: ContentAnalysis;
}

// =================== ENHANCED CONTENT ANALYZER ===================

async function analyzeContent(url: string): Promise<ContentAnalysis> {
  console.log(`üîç Starting content analysis for: ${url}`);
  
  try {
    let response: Response;
    let usedRange = false;
    
    try {
      console.log(`üì° Attempting range request for: ${url}`);
      response = await fetch(url, {
        headers: { 'Range': 'bytes=0-8191' }
      });
      
      if (response.status === 206) {
        usedRange = true;
        console.log(`‚úÖ Range request successful for: ${url}`);
      } else if (response.status === 416) {
        console.log(`‚ö†Ô∏è Range not supported, falling back to full request for: ${url}`);
        response = await fetch(url);
      } else if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    } catch (rangeError) {
      console.log(`‚ö†Ô∏è Range request failed, trying full request for: ${url}`, rangeError);
      response = await fetch(url);
    }

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const contentLength = response.headers.get('content-length');
    
    console.log(`üìä Content analysis - Type: ${contentType}, Length: ${contentLength}, Range: ${usedRange}`);
    
    const arrayBuffer = await response.arrayBuffer();
    const bytes = new Uint8Array(usedRange ? arrayBuffer : arrayBuffer.slice(0, 8192));
    const textDecoder = new TextDecoder('utf-8', { fatal: false });
    
    console.log(`üì¶ Received ${bytes.length} bytes for analysis`);
    
    let textContent = '';
    try {
      textContent = textDecoder.decode(bytes);
    } catch {
      // Not valid UTF-8, likely binary
    }

    const info = analyzeContentType(contentType, bytes, textContent, url);
    
    return {
      contentInfo: { ...info, mimeType: contentType },
      preview: info.detectedType === 'text' ? textContent.slice(0, 200) : undefined
    };
  } catch (error: any) {
    return {
      contentInfo: {
        mimeType: 'application/octet-stream',
        detectedType: 'unknown',
        renderStrategy: 'iframe',
        isInlineable: false
      },
      error: error.message
    };
  }
}

function analyzeContentType(mimeType: string, bytes: Uint8Array, textContent: string, url: string): Omit<ContentInfo, 'mimeType'> {
  const lowerMime = mimeType.toLowerCase();
  const urlPath = new URL(url).pathname;
  const fileExtension = urlPath.split('.').pop()?.toLowerCase();

  // Text-based content
  if (lowerMime.startsWith('text/')) {
    if (lowerMime === 'text/html') {
      return { detectedType: 'html', renderStrategy: 'native', fileExtension, isInlineable: true };
    }
    return { detectedType: 'text', renderStrategy: 'native', fileExtension, encoding: 'utf-8', isInlineable: true };
  }

  // Images
  if (lowerMime.startsWith('image/')) {
    if (lowerMime === 'image/svg+xml') {
      return { detectedType: 'svg', renderStrategy: 'native', fileExtension, isInlineable: true };
    }
    return { detectedType: 'image', renderStrategy: 'native', fileExtension, isInlineable: true };
  }

  // Audio
  if (lowerMime.startsWith('audio/')) {
    return { detectedType: 'audio', renderStrategy: 'native', fileExtension, isInlineable: true };
  }

  // Video
  if (lowerMime.startsWith('video/')) {
    return { detectedType: 'video', renderStrategy: 'native', fileExtension, isInlineable: true };
  }

  // Application types
  if (lowerMime.startsWith('application/')) {
    if (lowerMime.includes('json')) {
      return { detectedType: 'json', renderStrategy: 'native', fileExtension, isInlineable: true };
    }
    
    if (lowerMime.includes('gltf') || lowerMime.includes('obj') || 
        ['obj', 'gltf', 'glb', 'stl', '3ds', 'dae', 'fbx', 'blend'].includes(fileExtension || '')) {
      return { detectedType: '3d', renderStrategy: 'native', fileExtension, isInlineable: true };
    }

    if (lowerMime === 'application/pdf' || lowerMime.includes('document')) {
      return { detectedType: 'binary', renderStrategy: 'iframe', fileExtension, isInlineable: false };
    }
  }

  // Content-based detection
  if (textContent) {
    if (textContent.includes('<!DOCTYPE') || textContent.includes('<html') || 
        textContent.includes('<head>') || textContent.includes('<body>')) {
      return { detectedType: 'html', renderStrategy: 'native', fileExtension, isInlineable: true };
    }
    
    const trimmed = textContent.trim();
    if ((trimmed.startsWith('{') && trimmed.includes('}')) || 
        (trimmed.startsWith('[') && trimmed.includes(']'))) {
      try {
        JSON.parse(trimmed);
        return { detectedType: 'json', renderStrategy: 'native', fileExtension, isInlineable: true };
      } catch {
        // Not valid JSON, treat as text
      }
    }
    
    if (textContent.includes('<svg') || textContent.includes('xmlns="http://www.w3.org/2000/svg"')) {
      return { detectedType: 'svg', renderStrategy: 'native', fileExtension, isInlineable: true };
    }
    
    return { detectedType: 'text', renderStrategy: 'native', fileExtension, encoding: 'utf-8', isInlineable: true };
  }

  // Binary detection via magic bytes
  if (bytes.length >= 4) {
    const magic = Array.from(bytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('');
    
    if (magic === '89504e47') return { detectedType: 'image', renderStrategy: 'native', fileExtension: 'png', isInlineable: true };
    if (magic.startsWith('ffd8')) return { detectedType: 'image', renderStrategy: 'native', fileExtension: 'jpg', isInlineable: true };
    if (magic === '47494638') return { detectedType: 'image', renderStrategy: 'native', fileExtension: 'gif', isInlineable: true };
    if (magic === '52494646') return { detectedType: 'image', renderStrategy: 'native', fileExtension: 'webp', isInlineable: true };
  }

  return { detectedType: 'binary', renderStrategy: 'iframe', fileExtension, isInlineable: false };
}

function shouldLazyLoad(contentInfo: ContentInfo, contentLength?: number): boolean {
  if (contentLength && contentLength > 1024 * 1024) return true; // > 1MB
  if (contentInfo.detectedType === 'video' || contentInfo.detectedType === 'audio') return true;
  if (contentInfo.detectedType === '3d') return true;
  if (contentInfo.renderStrategy === 'iframe') return true;
  return false;
}

// =================== ENHANCED CACHE IMPLEMENTATION ===================

class InscriptionContentCache {
  private cache = new Map<string, { content: string; contentType: string; timestamp: number }>();
  private maxAge = 5 * 60 * 1000; // 5 minutes
  private maxSize = 100; // Maximum number of cached items

  get(id: string) {
    const cached = this.cache.get(id);
    if (cached && Date.now() - cached.timestamp < this.maxAge) {
      return cached;
    }
    if (cached) this.cache.delete(id);
    return null;
  }

  set(id: string, content: string, contentType: string) {
    // Clean up old entries if cache is full
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    
    this.cache.set(id, { content, contentType, timestamp: Date.now() });
  }

  remove(id: string) {
    this.cache.delete(id);
  }

  clear() {
    this.cache.clear();
  }

  size() {
    return this.cache.size;
  }
}

const inscriptionContentCache = new InscriptionContentCache();

// =================== ENHANCED UI COMPONENTS ===================

const Button: React.FC<{
  variant?: 'default' | 'ghost' | 'outline';
  size?: 'sm' | 'md';
  onClick?: () => void;
  disabled?: boolean;
  className?: string;
  children: React.ReactNode;
}> = ({ variant = 'default', size = 'md', onClick, disabled, className = '', children }) => {
  const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none';
  
  const variants = {
    default: 'bg-blue-600 text-white hover:bg-blue-700',
    ghost: 'hover:bg-gray-100 hover:text-gray-900',
    outline: 'border border-gray-300 bg-white hover:bg-gray-50'
  };
  
  const sizes = {
    sm: 'h-8 px-3 text-xs',
    md: 'h-10 px-4 py-2 text-sm'
  };

  return (
    <button
      className={`${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};

const Slider: React.FC<{
  value: number[];
  onValueChange: (value: number[]) => void;
  max: number;
  step: number;
  className?: string;
}> = ({ value, onValueChange, max, step, className = '' }) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onValueChange([parseFloat(e.target.value)]);
  };

  return (
    <div className={`relative ${className}`}>
      <input
        type="range"
        min="0"
        max={max}
        step={step}
        value={value[0]}
        onChange={handleChange}
        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider focus:outline-none focus:ring-2 focus:ring-blue-500"
        style={{
          background: `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${(value[0] / max) * 100}%, #e5e7eb ${(value[0] / max) * 100}%, #e5e7eb 100%)`
        }}
      />
    </div>
  );
};

// =================== DIALOG/MODAL COMPONENTS ===================

const Dialog: React.FC<{
  open: boolean;
  onOpenChange: (open: boolean) => void;
  children: React.ReactNode;
}> = ({ open, onOpenChange, children }) => {
  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div 
        className="fixed inset-0 bg-black/50" 
        onClick={() => onOpenChange(false)}
      />
      <div className="relative bg-white rounded-lg shadow-lg max-w-[95vw] max-h-[95vh] overflow-hidden">
        {children}
      </div>
    </div>
  );
};

const DialogTrigger: React.FC<{ children: React.ReactNode; asChild?: boolean }> = ({ children }) => children as React.ReactElement;

const DialogContent: React.FC<{
  className?: string;
  children: React.ReactNode;
  hideCloseButton?: boolean;
}> = ({ className = '', children, hideCloseButton = false }) => (
  <div className={`relative ${className}`}>
    {children}
  </div>
);

const DialogHeader: React.FC<{ className?: string; children: React.ReactNode }> = ({ className = '', children }) => (
  <div className={className}>{children}</div>
);

const DialogTitle: React.FC<{ className?: string; children: React.ReactNode }> = ({ className = '', children }) => (
  <h2 className={`text-lg font-semibold ${className}`}>{children}</h2>
);

// =================== ADVANCED RENDERERS ===================

const TextRenderer: React.FC<{
  content: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ content, mimeType, fileExtension, maxHeight = 400, showControls = true }) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  const handleDownload = () => {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `content.${fileExtension || 'txt'}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const isCode = useMemo(() => {
    const codeTypes = ['javascript', 'typescript', 'json', 'html', 'css', 'xml', 'yaml', 'python', 'java', 'c', 'cpp', 'rust', 'go'];
    const codeExtensions = ['js', 'ts', 'jsx', 'tsx', 'json', 'html', 'css', 'xml', 'yaml', 'yml', 'py', 'java', 'c', 'cpp', 'rs', 'go', 'php', 'rb', 'sql'];
    
    return mimeType.includes('javascript') || 
           mimeType.includes('json') || 
           mimeType.includes('xml') ||
           mimeType.includes('html') ||
           codeTypes.some(type => mimeType.includes(type)) ||
           codeExtensions.includes(fileExtension || '');
  }, [mimeType, fileExtension]);

  const language = useMemo(() => {
    if (mimeType.includes('javascript')) return 'javascript';
    if (mimeType.includes('typescript')) return 'typescript';
    if (mimeType.includes('json')) return 'json';
    if (mimeType.includes('html')) return 'html';
    if (mimeType.includes('css')) return 'css';
    if (mimeType.includes('xml')) return 'xml';
    if (mimeType.includes('yaml')) return 'yaml';
    if (mimeType.includes('python')) return 'python';
    
    const extMap: Record<string, string> = {
      'js': 'javascript', 'ts': 'typescript', 'jsx': 'javascript', 'tsx': 'typescript',
      'json': 'json', 'html': 'html', 'css': 'css', 'xml': 'xml',
      'yaml': 'yaml', 'yml': 'yaml', 'py': 'python', 'java': 'java',
      'c': 'c', 'cpp': 'cpp', 'rs': 'rust', 'go': 'go',
      'php': 'php', 'rb': 'ruby', 'sql': 'sql'
    };
    
    return extMap[fileExtension || ''] || 'text';
  }, [mimeType, fileExtension]);

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">{language}</span>
            <span className="ml-2">({content.length.toLocaleString()} chars)</span>
          </div>
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={handleCopy} className="h-6 px-2 text-xs">
              <Copy className="h-3 w-3 mr-1" />
              {copied ? 'Copied!' : 'Copy'}
            </Button>
            <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
              <Download className="h-3 w-3 mr-1" />
              Download
            </Button>
          </div>
        </div>
      )}
      <div className="flex-1 overflow-auto">
        <pre 
          className={`text-xs p-4 h-full overflow-auto font-mono whitespace-pre-wrap break-words ${
            isCode 
              ? 'bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200' 
              : 'bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100'
          }`}
          style={{ maxHeight }}
        >
          {content}
        </pre>
      </div>
    </div>
  );
};

const ImageRenderer: React.FC<{
  src: string;
  alt?: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ src, alt = 'Inscription image', mimeType, fileExtension, maxHeight = 400, showControls = true }) => {
  const [zoom, setZoom] = useState(1);
  const [rotation, setRotation] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [imageDimensions, setImageDimensions] = useState<{width: number, height: number} | null>(null);

  const handleImageLoad = (e: React.SyntheticEvent<HTMLImageElement>) => {
    setImageLoaded(true);
    const img = e.target as HTMLImageElement;
    setImageDimensions({ width: img.naturalWidth, height: img.naturalHeight });
  };

  const handleDownload = async () => {
    try {
      const response = await fetch(src);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `image.${fileExtension || 'png'}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download:', err);
    }
  };

  const resetTransform = () => {
    setZoom(1);
    setRotation(0);
  };

  if (imageError) {
    return (
      <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
        <div className="text-center text-gray-500">
          <div className="text-2xl mb-2">üñºÔ∏è</div>
          <div className="text-sm">Failed to load image</div>
          <div className="text-xs mt-1 text-gray-400">{mimeType} ‚Ä¢ {fileExtension}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && imageLoaded && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">{mimeType.split('/')[1]}</span>
            {imageDimensions && (
              <span className="ml-2">{imageDimensions.width} √ó {imageDimensions.height}</span>
            )}
          </div>
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={() => setZoom(Math.max(0.1, zoom - 0.2))} className="h-6 px-2 text-xs" disabled={zoom <= 0.2}>
              <ZoomOut className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={() => setZoom(Math.min(5, zoom + 0.2))} className="h-6 px-2 text-xs" disabled={zoom >= 5}>
              <ZoomIn className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={() => setRotation((rotation + 90) % 360)} className="h-6 px-2 text-xs">
              <RotateCw className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={resetTransform} className="h-6 px-2 text-xs">
              Reset
            </Button>
            <Button variant="ghost" size="sm" onClick={() => setIsFullscreen(!isFullscreen)} className="h-6 px-2 text-xs">
              <Maximize2 className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
              <Download className="h-3 w-3" />
            </Button>
          </div>
        </div>
      )}
      <div 
        className={`flex-1 overflow-auto flex items-center justify-center bg-gray-50 dark:bg-gray-800 ${
          isFullscreen ? 'fixed inset-0 z-50 bg-black' : ''
        }`}
        style={{ maxHeight: isFullscreen ? '100vh' : maxHeight }}
      >
        <img
          src={src}
          alt={alt}
          className="max-w-full max-h-full object-contain transition-transform duration-200"
          style={{
            transform: `scale(${zoom}) rotate(${rotation}deg)`,
            cursor: zoom > 1 ? 'move' : 'default'
          }}
          onLoad={handleImageLoad}
          onError={() => setImageError(true)}
          draggable={false}
        />
        
        {!imageLoaded && !imageError && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-gray-500">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
              <div className="text-sm">Loading image...</div>
            </div>
          </div>
        )}
        
        {isFullscreen && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setIsFullscreen(false)}
            className="absolute top-4 right-4 bg-black/50 text-white hover:bg-black/70"
          >
            ‚úï Exit Fullscreen
          </Button>
        )}
      </div>
    </div>
  );
};

const VideoRenderer: React.FC<{
  src: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ src, mimeType, fileExtension, maxHeight = 400, showControls = true }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [videoDimensions, setVideoDimensions] = useState<{width: number, height: number} | null>(null);

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => setCurrentTime(video.currentTime);
    const handleDurationChange = () => setDuration(video.duration);
    const handleEnded = () => setIsPlaying(false);
    const handleCanPlay = () => setIsLoaded(true);
    const handleError = () => setError('Failed to load video');
    const handleLoadedMetadata = () => {
      setVideoDimensions({ width: video.videoWidth, height: video.videoHeight });
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('durationchange', handleDurationChange);
    video.addEventListener('ended', handleEnded);
    video.addEventListener('canplay', handleCanPlay);
    video.addEventListener('error', handleError);
    video.addEventListener('loadedmetadata', handleLoadedMetadata);

    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('durationchange', handleDurationChange);
      video.removeEventListener('ended', handleEnded);
      video.removeEventListener('canplay', handleCanPlay);
      video.removeEventListener('error', handleError);
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
    };
  }, []);

  const togglePlay = () => {
    const video = videoRef.current;
    if (!video) return;

    if (isPlaying) {
      video.pause();
    } else {
      video.play();
    }
    setIsPlaying(!isPlaying);
  };

  const handleSeek = (value: number[]) => {
    const video = videoRef.current;
    if (!video || !duration) return;
    
    const newTime = (value[0] / 100) * duration;
    video.currentTime = newTime;
    setCurrentTime(newTime);
  };

  const handleVolumeChange = (value: number[]) => {
    const video = videoRef.current;
    if (!video) return;
    
    const newVolume = value[0] / 100;
    video.volume = newVolume;
    setVolume(newVolume);
    setIsMuted(newVolume === 0);
  };

  const toggleMute = () => {
    const video = videoRef.current;
    if (!video) return;
    
    if (isMuted) {
      video.volume = volume;
      setIsMuted(false);
    } else {
      video.volume = 0;
      setIsMuted(true);
    }
  };

  const toggleFullscreen = () => {
    const video = videoRef.current;
    if (!video) return;

    if (!isFullscreen) {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
    setIsFullscreen(!isFullscreen);
  };

  const skip = (seconds: number) => {
    const video = videoRef.current;
    if (!video) return;
    
    video.currentTime = Math.max(0, Math.min(duration, video.currentTime + seconds));
  };

  const handleDownload = async () => {
    try {
      const response = await fetch(src);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `video.${fileExtension || 'mp4'}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download:', err);
    }
  };

  const formatTime = (time: number) => {
    const hours = Math.floor(time / 3600);
    const minutes = Math.floor((time % 3600) / 60);
    const seconds = Math.floor(time % 60);
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  if (error) {
    return (
      <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
        <div className="text-center text-gray-500">
          <div className="text-2xl mb-2">üé¨</div>
          <div className="text-sm">Failed to load video</div>
          <div className="text-xs mt-1 text-gray-400">{mimeType} ‚Ä¢ {fileExtension}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-black">
      {showControls && isLoaded && (
        <div className="flex justify-between items-center p-2 bg-gray-900 text-white text-xs">
          <div>
            <span className="font-mono">{mimeType.split('/')[1].toUpperCase()}</span>
            {videoDimensions && (
              <span className="ml-2">{videoDimensions.width} √ó {videoDimensions.height}</span>
            )}
          </div>
          <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs text-white hover:bg-gray-700">
            <Download className="h-3 w-3 mr-1" />
            Download
          </Button>
        </div>
      )}

      <div className="flex-1 relative bg-black">
        <video
          ref={videoRef}
          src={src}
          className="w-full h-full object-contain"
          style={{ maxHeight }}
          onClick={togglePlay}
          onError={() => setError('Failed to load video')}
        />
        
        {!isLoaded && !error && (
          <div className="absolute inset-0 flex items-center justify-center bg-black">
            <div className="text-center text-white">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto mb-2"></div>
              <div className="text-sm">Loading video...</div>
            </div>
          </div>
        )}

        {isLoaded && (
          <div 
            className="absolute inset-0 flex items-center justify-center cursor-pointer opacity-0 hover:opacity-100 transition-opacity bg-black/20"
            onClick={togglePlay}
          >
            <div className="bg-black/50 rounded-full p-4">
              {isPlaying ? (
                <Pause className="h-8 w-8 text-white" />
              ) : (
                <Play className="h-8 w-8 text-white" />
              )}
            </div>
          </div>
        )}
      </div>

      {showControls && isLoaded && (
        <div className="p-3 bg-gray-900 text-white">
          {duration > 0 && (
            <div className="mb-3">
              <Slider
                value={[duration > 0 ? (currentTime / duration) * 100 : 0]}
                onValueChange={handleSeek}
                max={100}
                step={0.1}
                className="w-full"
              />
              <div className="flex justify-between text-xs text-gray-400 mt-1">
                <span>{formatTime(currentTime)}</span>
                <span>{formatTime(duration)}</span>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Button variant="ghost" size="sm" onClick={() => skip(-10)} className="h-8 w-8 p-0 text-white hover:bg-gray-700">
                <SkipBack className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="sm" onClick={togglePlay} className="h-10 w-10 p-0 rounded-full text-white hover:bg-gray-700">
                {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5" />}
              </Button>
              <Button variant="ghost" size="sm" onClick={() => skip(10)} className="h-8 w-8 p-0 text-white hover:bg-gray-700">
                <SkipForward className="h-4 w-4" />
              </Button>
            </div>

            <div className="flex items-center gap-2">
              <Button variant="ghost" size="sm" onClick={toggleMute} className="h-8 w-8 p-0 text-white hover:bg-gray-700">
                {isMuted || volume === 0 ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
              </Button>
              <div className="w-20">
                <Slider
                  value={[isMuted ? 0 : volume * 100]}
                  onValueChange={handleVolumeChange}
                  max={100}
                  step={1}
                />
              </div>
              <Button variant="ghost" size="sm" onClick={toggleFullscreen} className="h-8 w-8 p-0 text-white hover:bg-gray-700">
                <Maximize2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const AudioRenderer: React.FC<{
  src: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ src, mimeType, fileExtension, maxHeight = 300, showControls = true }) => {
  const audioRef = useRef<HTMLAudioElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handleTimeUpdate = () => setCurrentTime(audio.currentTime);
    const handleDurationChange = () => setDuration(audio.duration);
    const handleEnded = () => setIsPlaying(false);
    const handleCanPlay = () => setIsLoaded(true);
    const handleError = () => setError('Failed to load audio');

    audio.addEventListener('timeupdate', handleTimeUpdate);
    audio.addEventListener('durationchange', handleDurationChange);
    audio.addEventListener('ended', handleEnded);
    audio.addEventListener('canplay', handleCanPlay);
    audio.addEventListener('error', handleError);

    return () => {
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      audio.removeEventListener('durationchange', handleDurationChange);
      audio.removeEventListener('ended', handleEnded);
      audio.removeEventListener('canplay', handleCanPlay);
      audio.removeEventListener('error', handleError);
    };
  }, []);

  const togglePlay = () => {
    const audio = audioRef.current;
    if (!audio) return;

    if (isPlaying) {
      audio.pause();
    } else {
      audio.play();
    }
    setIsPlaying(!isPlaying);
  };

  const handleSeek = (value: number[]) => {
    const audio = audioRef.current;
    if (!audio || !duration) return;
    
    const newTime = (value[0] / 100) * duration;
    audio.currentTime = newTime;
    setCurrentTime(newTime);
  };

  const handleVolumeChange = (value: number[]) => {
    const audio = audioRef.current;
    if (!audio) return;
    
    const newVolume = value[0] / 100;
    audio.volume = newVolume;
    setVolume(newVolume);
    setIsMuted(newVolume === 0);
  };

  const toggleMute = () => {
    const audio = audioRef.current;
    if (!audio) return;
    
    if (isMuted) {
      audio.volume = volume;
      setIsMuted(false);
    } else {
      audio.volume = 0;
      setIsMuted(true);
    }
  };

  const skip = (seconds: number) => {
    const audio = audioRef.current;
    if (!audio) return;
    
    audio.currentTime = Math.max(0, Math.min(duration, audio.currentTime + seconds));
  };

  const handleDownload = async () => {
    try {
      const response = await fetch(src);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audio.${fileExtension || 'mp3'}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download:', err);
    }
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  if (error) {
    return (
      <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
        <div className="text-center text-gray-500">
          <div className="text-2xl mb-2">üéµ</div>
          <div className="text-sm">Failed to load audio</div>
          <div className="text-xs mt-1 text-gray-400">{mimeType} ‚Ä¢ {fileExtension}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      <audio ref={audioRef} src={src} preload="metadata" />

      <div className="flex-1 flex items-center justify-center bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-800 dark:to-gray-900 min-h-32">
        <div className="text-center">
          <div className="text-6xl mb-4">üéµ</div>
          <div className="text-lg font-medium text-gray-700 dark:text-gray-300">Audio Player</div>
          <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {mimeType.split('/')[1].toUpperCase()} ‚Ä¢ {fileExtension}
          </div>
          {duration > 0 && (
            <div className="text-xs text-gray-400 mt-2">Duration: {formatTime(duration)}</div>
          )}
        </div>
      </div>

      {showControls && (
        <div className="p-4 border-t bg-gray-50 dark:bg-gray-800">
          {duration > 0 && (
            <div className="mb-4">
              <Slider
                value={[duration > 0 ? (currentTime / duration) * 100 : 0]}
                onValueChange={handleSeek}
                max={100}
                step={0.1}
                className="w-full"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>{formatTime(currentTime)}</span>
                <span>{formatTime(duration)}</span>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Button variant="ghost" size="sm" onClick={() => skip(-10)} disabled={!isLoaded} className="h-8 w-8 p-0">
                <SkipBack className="h-4 w-4" />
              </Button>
              <Button variant="default" size="sm" onClick={togglePlay} disabled={!isLoaded} className="h-10 w-10 p-0 rounded-full">
                {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5" />}
              </Button>
              <Button variant="ghost" size="sm" onClick={() => skip(10)} disabled={!isLoaded} className="h-8 w-8 p-0">
                <SkipForward className="h-4 w-4" />
              </Button>
            </div>

            <div className="flex items-center gap-2">
              <Button variant="ghost" size="sm" onClick={toggleMute} className="h-8 w-8 p-0">
                {isMuted || volume === 0 ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
              </Button>
              <div className="w-20">
                <Slider
                  value={[isMuted ? 0 : volume * 100]}
                  onValueChange={handleVolumeChange}
                  max={100}
                  step={1}
                />
              </div>
              <Button variant="ghost" size="sm" onClick={handleDownload} className="h-8 w-8 p-0">
                <Download className="h-4 w-4" />
              </Button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const JsonRenderer: React.FC<{
  content: string;
  mimeType: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ content, mimeType, maxHeight = 400, showControls = true }) => {
  const [parsedJson, setParsedJson] = useState<any>(null);
  const [parseError, setParseError] = useState<string | null>(null);
  const [collapsed, setCollapsed] = useState<Set<string>>(new Set());
  const [allCollapsed, setAllCollapsed] = useState(false);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    try {
      const parsed = JSON.parse(content);
      setParsedJson(parsed);
      setParseError(null);
    } catch (err: any) {
      setParseError(err.message);
      setParsedJson(null);
    }
  }, [content]);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  const handleDownload = () => {
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'data.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const toggleCollapse = (path: string) => {
    const newCollapsed = new Set(collapsed);
    if (newCollapsed.has(path)) {
      newCollapsed.delete(path);
    } else {
      newCollapsed.add(path);
    }
    setCollapsed(newCollapsed);
  };

  const toggleAllCollapse = () => {
    if (allCollapsed) {
      setCollapsed(new Set());
    } else {
      const allPaths = new Set<string>();
      const findPaths = (obj: any, path: string = '') => {
        if (typeof obj === 'object' && obj !== null) {
          if (path) allPaths.add(path);
          Object.keys(obj).forEach(key => {
            const newPath = path ? `${path}.${key}` : key;
            findPaths(obj[key], newPath);
          });
        }
      };
      if (parsedJson) findPaths(parsedJson);
      setCollapsed(allPaths);
    }
    setAllCollapsed(!allCollapsed);
  };

  const renderValue = (value: any, path: string = '', depth: number = 0): React.ReactNode => {
    if (value === null) {
      return <span className="text-gray-500">null</span>;
    }
    
    if (typeof value === 'boolean') {
      return <span className="text-blue-600 dark:text-blue-400">{value.toString()}</span>;
    }
    
    if (typeof value === 'number') {
      return <span className="text-purple-600 dark:text-purple-400">{value}</span>;
    }
    
    if (typeof value === 'string') {
      return <span className="text-green-600 dark:text-green-400">"{value}"</span>;
    }
    
    if (Array.isArray(value)) {
      const isCollapsed = collapsed.has(path);
      return (
        <div>
          <span 
            className="cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-1 rounded"
            onClick={() => toggleCollapse(path)}
          >
            <span className="text-gray-500">
              {isCollapsed ? '‚ñ∫' : '‚ñº'} [{value.length}]
            </span>
          </span>
          {!isCollapsed && (
            <div className="ml-4">
              {value.map((item, index) => (
                <div key={index} className="font-mono text-sm">
                  <span className="text-gray-400">{index}: </span>
                  {renderValue(item, `${path}[${index}]`, depth + 1)}
                  {index < value.length - 1 && <span className="text-gray-500">,</span>}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }
    
    if (typeof value === 'object') {
      const keys = Object.keys(value);
      const isCollapsed = collapsed.has(path);
      return (
        <div>
          <span 
            className="cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-1 rounded"
            onClick={() => toggleCollapse(path)}
          >
            <span className="text-gray-500">
              {isCollapsed ? '‚ñ∫' : '‚ñº'} {`{${keys.length}}`}
            </span>
          </span>
          {!isCollapsed && (
            <div className="ml-4">
              {keys.map((key, index) => (
                <div key={key} className="font-mono text-sm">
                  <span className="text-blue-600 dark:text-blue-400">"{key}"</span>
                  <span className="text-gray-500">: </span>
                  {renderValue(value[key], path ? `${path}.${key}` : key, depth + 1)}
                  {index < keys.length - 1 && <span className="text-gray-500">,</span>}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }
    
    return <span>{String(value)}</span>;
  };

  if (parseError) {
    return (
      <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
        {showControls && (
          <div className="flex justify-between items-center p-2 border-b bg-red-50 dark:bg-red-900/20">
            <div className="text-xs text-red-600 dark:text-red-400">
              <span className="font-mono">Invalid JSON</span>
            </div>
            <Button variant="ghost" size="sm" onClick={handleCopy} className="h-6 px-2 text-xs">
              <Copy className="h-3 w-3 mr-1" />
              Copy Raw
            </Button>
          </div>
        )}
        <div className="flex-1 p-4">
          <div className="text-red-600 dark:text-red-400 mb-2">JSON Parse Error:</div>
          <div className="text-sm text-red-500 mb-4">{parseError}</div>
          <pre className="text-xs font-mono bg-gray-100 dark:bg-gray-800 p-3 rounded overflow-auto whitespace-pre-wrap">
            {content}
          </pre>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">JSON</span>
            <span className="ml-2">({content.length.toLocaleString()} chars)</span>
          </div>
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={toggleAllCollapse} className="h-6 px-2 text-xs">
              {allCollapsed ? <Expand className="h-3 w-3 mr-1" /> : <Minimize className="h-3 w-3 mr-1" />}
              {allCollapsed ? 'Expand' : 'Collapse'}
            </Button>
            <Button variant="ghost" size="sm" onClick={handleCopy} className="h-6 px-2 text-xs">
              <Copy className="h-3 w-3 mr-1" />
              {copied ? 'Copied!' : 'Copy'}
            </Button>
            <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
              <Download className="h-3 w-3 mr-1" />
              Download
            </Button>
          </div>
        </div>
      )}
      <div className="flex-1 overflow-auto p-4 font-mono text-sm" style={{ maxHeight }}>
        {parsedJson && renderValue(parsedJson)}
      </div>
    </div>
  );
};

const HtmlRenderer: React.FC<{
  content: string;
  src?: string;
  mimeType: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ content, src, mimeType, maxHeight = 400, showControls = true }) => {
  const [showSource, setShowSource] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const iframeRef = useRef<HTMLIFrameElement>(null);

  const blobUrl = useMemo(() => {
    if (!content) return src;
    
    try {
      const blob = new Blob([content], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      return url;
    } catch (err: any) {
      setError(err.message);
      return null;
    }
  }, [content, src]);

  useEffect(() => {
    return () => {
      if (blobUrl && blobUrl.startsWith('blob:')) {
        URL.revokeObjectURL(blobUrl);
      }
    };
  }, [blobUrl]);

  const handleDownload = () => {
    const htmlContent = content || '';
    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'content.html';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const handleOpenExternal = () => {
    if (blobUrl) {
      window.open(blobUrl, '_blank');
    }
  };

  if (error) {
    return (
      <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
        <div className="text-center text-gray-500">
          <div className="text-2xl mb-2">üåê</div>
          <div className="text-sm">Failed to render HTML</div>
          <div className="text-xs mt-1 text-gray-400">{error}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">HTML</span>
            {content && <span className="ml-2">({content.length.toLocaleString()} chars)</span>}
          </div>
          <div className="flex gap-1">
            {content && (
              <Button variant="ghost" size="sm" onClick={() => setShowSource(!showSource)} className="h-6 px-2 text-xs">
                {showSource ? <Eye className="h-3 w-3 mr-1" /> : <EyeOff className="h-3 w-3 mr-1" />}
                {showSource ? 'Rendered' : 'Source'}
              </Button>
            )}
            <Button variant="ghost" size="sm" onClick={handleOpenExternal} className="h-6 px-2 text-xs">
              <ExternalLink className="h-3 w-3 mr-1" />
              Open
            </Button>
            {content && (
              <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
                <Download className="h-3 w-3 mr-1" />
                Download
              </Button>
            )}
          </div>
        </div>
      )}
      <div className="flex-1 overflow-hidden">
        {showSource && content ? (
          <pre 
            className="text-xs p-4 h-full overflow-auto font-mono whitespace-pre-wrap break-words bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200"
            style={{ maxHeight }}
          >
            {content}
          </pre>
        ) : (
          <iframe
            ref={iframeRef}
            src={blobUrl || undefined}
            className="w-full h-full border-0"
            style={{ maxHeight }}
            sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-popups-to-escape-sandbox"
            title="HTML Content"
            onError={() => setError('Failed to load HTML content')}
          />
        )}
      </div>
    </div>
  );
};

const ThreeDRenderer: React.FC<{
  src: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ src, mimeType, fileExtension, maxHeight = 400, showControls = true }) => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const modelRef = useRef<THREE.Object3D | null>(null);
  const frameRef = useRef<number>();
  
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [zoom, setZoom] = useState(1);
  const [autoRotate, setAutoRotate] = useState(true);

  const [isDragging, setIsDragging] = useState(false);
  const [previousMousePosition, setPreviousMousePosition] = useState({ x: 0, y: 0 });
  const rotationRef = useRef({ x: 0, y: 0 });

  const isSupported = useMemo(() => {
    const supportedTypes = ['gltf', 'glb', 'obj'];
    const supportedExts = ['gltf', 'glb', 'obj', 'stl'];
    
    return supportedTypes.some(type => mimeType.includes(type)) ||
           supportedExts.includes(fileExtension?.toLowerCase() || '');
  }, [mimeType, fileExtension]);

  const initScene = useCallback(() => {
    if (!mountRef.current) return;

    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f5f5);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.set(0, 0, 5);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    rendererRef.current = renderer;

    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xffffff, 0.5);
    pointLight.position.set(-10, -10, -5);
    scene.add(pointLight);

    mountRef.current.appendChild(renderer.domElement);
  }, []);

  const loadModel = useCallback(async () => {
    if (!sceneRef.current) return;

    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(src);
      if (!response.ok) throw new Error('Failed to load model');
      
      const arrayBuffer = await response.arrayBuffer();
      const extension = fileExtension?.toLowerCase() || '';

      let object: THREE.Object3D | null = null;

      if (extension === 'obj') {
        const text = new TextDecoder().decode(arrayBuffer);
        object = parseOBJ(text);
      } else if (extension === 'stl') {
        object = parseSTL(arrayBuffer);
      } else {
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        object = new THREE.Mesh(geometry, material);
      }

      if (object) {
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        object.position.sub(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 3 / maxDim;
        object.scale.setScalar(scale);

        if (modelRef.current) {
          sceneRef.current.remove(modelRef.current);
        }

        sceneRef.current.add(object);
        modelRef.current = object;
      }

      setIsLoading(false);
    } catch (err) {
      console.error('Failed to load model:', err);
      setError('Failed to load 3D model');
      setIsLoading(false);
    }
  }, [src, fileExtension]);

  const parseOBJ = (text: string): THREE.Object3D => {
    const lines = text.split('\n');
    const vertices: number[] = [];
    const faces: number[] = [];

    for (const line of lines) {
      const parts = line.trim().split(/\s+/);
      if (parts[0] === 'v') {
        vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
      } else if (parts[0] === 'f') {
        for (let i = 1; i < parts.length; i++) {
          const vertexIndex = parseInt(parts[i].split('/')[0]) - 1;
          faces.push(vertexIndex);
        }
      }
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(faces);
    geometry.computeVertexNormals();

    const material = new THREE.MeshPhongMaterial({ color: 0x888888 });
    return new THREE.Mesh(geometry, material);
  };

  const parseSTL = (buffer: ArrayBuffer): THREE.Object3D => {
    const view = new DataView(buffer);
    const isASCII = buffer.byteLength < 80 || view.getUint32(80, true) * 50 + 84 !== buffer.byteLength;

    if (isASCII) {
      const text = new TextDecoder().decode(buffer);
      const vertices: number[] = [];
      const lines = text.split('\n');
      
      for (const line of lines) {
        if (line.trim().startsWith('vertex')) {
          const coords = line.trim().split(/\s+/).slice(1);
          vertices.push(parseFloat(coords[0]), parseFloat(coords[1]), parseFloat(coords[2]));
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
      return new THREE.Mesh(geometry, material);
    } else {
      const triangleCount = view.getUint32(80, true);
      const vertices: number[] = [];

      for (let i = 0; i < triangleCount; i++) {
        const offset = 84 + i * 50;
        for (let j = 0; j < 3; j++) {
          const vertexOffset = offset + 12 + j * 12;
          vertices.push(
            view.getFloat32(vertexOffset, true),
            view.getFloat32(vertexOffset + 4, true),
            view.getFloat32(vertexOffset + 8, true)
          );
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
      return new THREE.Mesh(geometry, material);
    }
  };

  const animate = useCallback(() => {
    if (!rendererRef.current || !sceneRef.current || !cameraRef.current) return;

    if (modelRef.current) {
      if (autoRotate) {
        modelRef.current.rotation.y += 0.01;
      }
      
      modelRef.current.rotation.x = rotationRef.current.x;
      modelRef.current.rotation.y += rotationRef.current.y;
    }

    if (cameraRef.current) {
      cameraRef.current.position.setLength(5 / zoom);
    }

    rendererRef.current.render(sceneRef.current, cameraRef.current);
    frameRef.current = requestAnimationFrame(animate);
  }, [autoRotate, zoom]);

  const handleMouseDown = (event: React.MouseEvent) => {
    setIsDragging(true);
    setAutoRotate(false);
    setPreviousMousePosition({ x: event.clientX, y: event.clientY });
  };

  const handleMouseMove = (event: React.MouseEvent) => {
    if (!isDragging) return;

    const deltaX = event.clientX - previousMousePosition.x;
    const deltaY = event.clientY - previousMousePosition.y;

    rotationRef.current.x += deltaY * 0.01;
    rotationRef.current.y += deltaX * 0.01;

    setPreviousMousePosition({ x: event.clientX, y: event.clientY });
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  const handleZoomIn = () => setZoom(prev => Math.min(prev * 1.2, 5));
  const handleZoomOut = () => setZoom(prev => Math.max(prev / 1.2, 0.1));
  const handleReset = () => {
    setZoom(1);
    rotationRef.current = { x: 0, y: 0 };
    setAutoRotate(true);
  };

  const handleDownload = async () => {
    try {
      const response = await fetch(src);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `model.${fileExtension || '3d'}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download:', err);
    }
  };

  useEffect(() => {
    if (isSupported) {
      initScene();
      loadModel();
      animate();
    }

    return () => {
      if (frameRef.current) {
        cancelAnimationFrame(frameRef.current);
      }
      if (rendererRef.current && mountRef.current) {
        mountRef.current.removeChild(rendererRef.current.domElement);
        rendererRef.current.dispose();
      }
    };
  }, [isSupported, initScene, loadModel, animate]);

  useEffect(() => {
    const handleResize = () => {
      if (rendererRef.current && cameraRef.current && mountRef.current) {
        const width = mountRef.current.clientWidth;
        const height = mountRef.current.clientHeight;
        
        cameraRef.current.aspect = width / height;
        cameraRef.current.updateProjectionMatrix();
        rendererRef.current.setSize(width, height);
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  if (!isSupported) {
    return (
      <div className="w-full h-full flex items-center justify-center bg-gray-100 dark:bg-gray-800">
        <div className="text-center text-gray-500">
          <div className="text-2xl mb-2">üéÆ</div>
          <div className="text-sm">3D Model Viewer</div>
          <div className="text-xs mt-1 text-gray-400">{fileExtension?.toUpperCase() || 'Unknown'} format</div>
          <div className="text-xs mt-2 text-red-500">Format not yet supported</div>
          <div className="mt-3">
            <Button variant="outline" size="sm" onClick={handleDownload} className="text-xs">
              <Download className="h-3 w-3 mr-1" />
              Download Model
            </Button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">3D Model</span>
            <span className="ml-2">{fileExtension?.toUpperCase()}</span>
            {isLoading && <span className="ml-2 text-blue-500">Loading...</span>}
            {error && <span className="ml-2 text-red-500">Error</span>}
          </div>
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={handleZoomOut} className="h-6 px-2 text-xs" disabled={isLoading}>
              <ZoomOut className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={handleZoomIn} className="h-6 px-2 text-xs" disabled={isLoading}>
              <ZoomIn className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={handleReset} className="h-6 px-2 text-xs" disabled={isLoading}>
              <RotateCcw className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={() => setAutoRotate(!autoRotate)} className="h-6 px-2 text-xs" disabled={isLoading}>
              <Move3D className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
              <Download className="h-3 w-3" />
            </Button>
          </div>
        </div>
      )}

      <div 
        ref={mountRef}
        className="flex-1 relative cursor-grab active:cursor-grabbing"
        style={{ maxHeight }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      >
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800 z-10">
            <div className="text-center">
              <div className="animate-spin text-2xl mb-2">‚öôÔ∏è</div>
              <div className="text-sm text-gray-600">Loading 3D model...</div>
            </div>
          </div>
        )}
        {error && (
          <div className="absolute inset-0 flex items-center justify-center bg-red-50 dark:bg-red-900/20 z-10">
            <div className="text-center text-red-600 dark:text-red-400">
              <div className="text-2xl mb-2">‚ö†Ô∏è</div>
              <div className="text-sm">{error}</div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const IframeRenderer: React.FC<{
  src: string;
  mimeType: string;
  fileExtension?: string;
  maxHeight?: number;
  showControls?: boolean;
}> = ({ src, mimeType, fileExtension, maxHeight = 400, showControls = true }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const iframeRef = useRef<HTMLIFrameElement>(null);

  const handleLoad = () => {
    setIsLoading(false);
    setError(null);
  };

  const handleError = () => {
    setIsLoading(false);
    setError('Failed to load content in iframe');
  };

  const handleRetry = () => {
    setIsLoading(true);
    setError(null);
    setRetryCount(prev => prev + 1);
    
    if (iframeRef.current) {
      iframeRef.current.src = src + `?retry=${retryCount}`;
    }
  };

  const handleDownload = async () => {
    try {
      const response = await fetch(src);
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `content.${fileExtension || 'bin'}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Failed to download:', err);
    }
  };

  const handleOpenExternal = () => {
    window.open(src, '_blank');
  };

  return (
    <div className="w-full h-full flex flex-col bg-white dark:bg-gray-900">
      {showControls && (
        <div className="flex justify-between items-center p-2 border-b bg-gray-50 dark:bg-gray-800">
          <div className="text-xs text-gray-600 dark:text-gray-400">
            <span className="font-mono">{fileExtension?.toUpperCase() || mimeType.split('/')[1].toUpperCase()}</span>
            <span className="ml-2 text-gray-500">(iframe)</span>
          </div>
          <div className="flex gap-1">
            <Button variant="ghost" size="sm" onClick={handleRetry} className="h-6 px-2 text-xs">
              <RefreshCw className="h-3 w-3 mr-1" />
              Retry
            </Button>
            <Button variant="ghost" size="sm" onClick={handleOpenExternal} className="h-6 px-2 text-xs">
              <ExternalLink className="h-3 w-3 mr-1" />
              Open
            </Button>
            <Button variant="ghost" size="sm" onClick={handleDownload} className="h-6 px-2 text-xs">
              <Download className="h-3 w-3 mr-1" />
              Download
            </Button>
          </div>
        </div>
      )}

      <div className="flex-1 relative bg-white dark:bg-gray-900">
        <iframe
          ref={iframeRef}
          src={src}
          className="w-full h-full border-0"
          style={{ maxHeight }}
          sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-popups-to-escape-sandbox"
          onLoad={handleLoad}
          onError={handleError}
          title={`Content: ${fileExtension || mimeType}`}
        />
        
        {isLoading && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800">
            <div className="text-center text-gray-500">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
              <div className="text-sm">Loading content...</div>
              <div className="text-xs mt-1 text-gray-400">{mimeType} ‚Ä¢ {fileExtension}</div>
            </div>
          </div>
        )}

        {error && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800">
            <div className="text-center text-gray-500">
              <div className="text-2xl mb-2">‚ö†Ô∏è</div>
              <div className="text-sm mb-2">{error}</div>
              <div className="text-xs text-gray-400 mb-4">{mimeType} ‚Ä¢ {fileExtension}</div>
              <div className="flex gap-2 justify-center">
                <Button variant="outline" size="sm" onClick={handleRetry} className="text-xs">
                  <RefreshCw className="h-3 w-3 mr-1" />
                  Retry
                </Button>
                <Button variant="outline" size="sm" onClick={handleOpenExternal} className="text-xs">
                  <ExternalLink className="h-3 w-3 mr-1" />
                  Open External
                </Button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// =================== CORE INSCRIPTION RENDERER ===================

const InscriptionRenderer: React.FC<{
  inscriptionId: string;
  inscriptionNumber?: number | string;
  contentUrl?: string;
  contentType?: string;
  size?: number;
  className?: string;
  showHeader?: boolean;
  showControls?: boolean;
  autoLoad?: boolean;
  onAnalysisComplete?: (analysis: ContentAnalysis) => void;
}> = ({
  inscriptionId,
  inscriptionNumber,
  contentUrl,
  contentType,
  size = 300,
  className = '',
  showHeader = true,
  showControls = true,
  autoLoad = true,
  onAnalysisComplete
}) => {
  const [loadedContent, setLoadedContent] = useState<LoadedContent | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [loadingStage, setLoadingStage] = useState<string>('');
  const isMountedRef = useRef(true);
  
  const finalContentUrl = contentUrl?.startsWith('http') 
    ? contentUrl
    : inscriptionNumber 
      ? `https://ordinals.com/content/${inscriptionNumber}` 
      : `https://ordinals.com/content/${inscriptionId.replace(':', 'i')}`;

  const loadContent = useCallback(async () => {
    if (!isMountedRef.current) return;
    
    setIsLoading(true);
    setError(null);
    setLoadingStage('Checking cache...');

    try {
      const cachedContent = inscriptionContentCache.get(inscriptionId);
      if (cachedContent && isMountedRef.current) {
        setLoadingStage('Loading from cache...');
        
        let blob: Blob | undefined;
        let text: string | undefined;
        
        if (cachedContent.contentType.startsWith('text/') || 
            cachedContent.contentType.includes('json') || 
            cachedContent.contentType.includes('html')) {
          text = cachedContent.content;
          blob = new Blob([text], { type: cachedContent.contentType });
        } else {
          try {
            const binaryString = atob(cachedContent.content);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            blob = new Blob([bytes], { type: cachedContent.contentType });
          } catch (e) {
            inscriptionContentCache.remove(inscriptionId);
            blob = undefined;
          }
        }
        
        if (blob) {
          const analysis = await analyzeContent(finalContentUrl);
          
          if (!isMountedRef.current) return;
          
          const objectUrl = URL.createObjectURL(blob);
          
          setLoadedContent({ url: objectUrl, blob, text, analysis });
          setIsLoading(false);
          setLoadingStage('');
          onAnalysisComplete?.(analysis);
          return;
        }
      }

      setLoadingStage('Analyzing content...');
      const analysis = await analyzeContent(finalContentUrl);
      
      if (!isMountedRef.current) return;
      
      if (analysis.error) {
        throw new Error(analysis.error);
      }

      onAnalysisComplete?.(analysis);
      setLoadingStage('Loading content...');

      const { contentInfo } = analysis;
      
      let blob: Blob;
      let text: string | undefined;
      let contentToCache: string;

      if (contentInfo.detectedType === 'text' || contentInfo.detectedType === 'json' || contentInfo.detectedType === 'html') {
        const response = await fetch(finalContentUrl);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        text = await response.text();
        contentToCache = text;
        blob = new Blob([text], { type: contentInfo.mimeType });
      } else {
        const response = await fetch(finalContentUrl);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        blob = await response.blob();
        
        const arrayBuffer = await blob.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        contentToCache = btoa(String.fromCharCode.apply(null, Array.from(uint8Array)));
      }

      if (!isMountedRef.current) return;

      setLoadingStage('Caching content...');
      inscriptionContentCache.set(inscriptionId, contentToCache, contentInfo.mimeType);

      const objectUrl = URL.createObjectURL(blob);
      
      setLoadedContent({ url: objectUrl, blob, text, analysis });
      setIsLoading(false);
      setLoadingStage('');

    } catch (err: any) {
      if (isMountedRef.current) {
        setError(err.message || 'Failed to load content');
        setIsLoading(false);
        setLoadingStage('');
      }
    }
  }, [finalContentUrl, inscriptionId, onAnalysisComplete]);

  const handleRetry = useCallback(() => {
    if (loadedContent?.url) {
      URL.revokeObjectURL(loadedContent.url);
    }
    setLoadedContent(null);
    setError(null);
    loadContent();
  }, [loadedContent, loadContent]);

  useEffect(() => {
    if (autoLoad) {
      loadContent();
    }
    
    return () => {
      isMountedRef.current = false;
      if (loadedContent?.url) {
        URL.revokeObjectURL(loadedContent.url);
      }
    };
  }, [autoLoad, loadContent]);

  const renderContent = () => {
    if (!loadedContent) return null;

    const { contentInfo } = loadedContent.analysis;
    const maxHeight = size - (showHeader ? 40 : 0) - (showControls ? 40 : 0);

    switch (contentInfo.detectedType) {
      case 'text':
        return (
          <TextRenderer
            content={loadedContent.text || ''}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'json':
        return (
          <JsonRenderer
            content={loadedContent.text || ''}
            mimeType={contentInfo.mimeType}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'html':
        return (
          <HtmlRenderer
            content={loadedContent.text || ''}
            src={loadedContent.url}
            mimeType={contentInfo.mimeType}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'image':
      case 'svg':
        return (
          <ImageRenderer
            src={loadedContent.url}
            alt={`Inscription ${inscriptionNumber || inscriptionId}`}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'video':
        return (
          <VideoRenderer
            src={loadedContent.url}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'audio':
        return (
          <AudioRenderer
            src={loadedContent.url}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case '3d':
        return (
          <ThreeDRenderer
            src={loadedContent.url}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );

      case 'binary':
      case 'unknown':
      default:
        return (
          <IframeRenderer
            src={loadedContent.url}
            mimeType={contentInfo.mimeType}
            fileExtension={contentInfo.fileExtension}
            maxHeight={maxHeight}
            showControls={showControls}
          />
        );
    }
  };

  const headerHeight = showHeader ? 40 : 0;
  
  return (
    <div 
      className={`border rounded-lg shadow-sm bg-white overflow-hidden ${className}`}
      style={{ width: size, height: size, minHeight: size }}
    >
      {showHeader && (
        <div className="px-3 py-2 bg-gray-100 border-b text-xs flex justify-between items-center h-10">
          <div className="flex items-center gap-2">
            <span className="text-gray-600 truncate">#{inscriptionNumber || 'N/A'}</span>
            {loadedContent && (
              <span className="text-gray-500 truncate" title={loadedContent.analysis.contentInfo.mimeType}>
                {loadedContent.analysis.contentInfo.detectedType}
              </span>
            )}
          </div>
          {error && (
            <Button variant="ghost" size="sm" onClick={handleRetry} className="h-6 px-2 text-xs text-blue-500 hover:text-blue-700">
              <RefreshCw className="h-3 w-3 mr-1" />
              Retry
            </Button>
          )}
        </div>
      )}
      
      <div className="relative w-full" style={{ height: `${size - headerHeight}px` }}>
        {isLoading && (
          <div className="absolute inset-0 bg-gray-100 flex items-center justify-center z-10">
            <div className="text-center">
              <Loader2 className="h-8 w-8 animate-spin text-blue-500 mx-auto mb-2" />
              <div className="text-xs text-gray-600">{loadingStage}</div>
              <div className="text-xs text-gray-500 mt-1">#{inscriptionNumber || 'N/A'}</div>
            </div>
          </div>
        )}

        {error && !isLoading && (
          <div className="absolute inset-0 bg-gray-100 flex items-center justify-center">
            <div className="text-center text-gray-500">
              <AlertCircle className="h-8 w-8 text-red-500 mx-auto mb-2" />
              <div className="text-xs mb-2 max-w-48 px-2">{error}</div>
              <Button variant="outline" size="sm" onClick={handleRetry} className="text-xs">
                <RefreshCw className="h-3 w-3 mr-1" />
                Retry
              </Button>
              <div className="text-xs text-gray-400 mt-2">#{inscriptionNumber || 'N/A'}</div>
            </div>
          </div>
        )}

        {loadedContent && !isLoading && !error && (
          <div className="w-full h-full">{renderContent()}</div>
        )}

        {!autoLoad && !loadedContent && !isLoading && !error && (
          <div className="absolute inset-0 bg-gray-100 flex items-center justify-center">
            <div className="text-center">
              <Button variant="outline" onClick={loadContent} className="text-sm">
                Load Content
              </Button>
              <div className="text-xs text-gray-500 mt-2">#{inscriptionNumber || 'N/A'}</div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// =================== INSCRIPTION MODAL COMPONENT ===================

const InscriptionModal: React.FC<{
  inscriptionId: string;
  inscriptionNumber?: number | string;
  contentUrl?: string;
  contentType?: string;
  trigger?: React.ReactNode;
  triggerClassName?: string;
  modalSize?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
  showTriggerButton?: boolean;
}> = ({
  inscriptionId,
  inscriptionNumber,
  contentUrl,
  contentType,
  trigger,
  triggerClassName = '',
  modalSize = 'lg',
  showTriggerButton = true
}) => {
  const [open, setOpen] = useState(false);
  const [analysis, setAnalysis] = useState<ContentAnalysis | null>(null);
  
  const modalSizes = {
    sm: { size: 400, className: 'max-w-md' },
    md: { size: 600, className: 'max-w-2xl' },
    lg: { size: 800, className: 'max-w-4xl' },
    xl: { size: 1000, className: 'max-w-6xl' },
    full: { size: 1200, className: 'max-w-[95vw] max-h-[95vh]' }
  };
  
  const { size, className } = modalSizes[modalSize];

  const handleAnalysisComplete = (contentAnalysis: ContentAnalysis) => {
    setAnalysis(contentAnalysis);
  };

  const defaultTrigger = showTriggerButton ? (
    <Button variant="outline" size="sm" className={triggerClassName}>
      <Eye className="h-4 w-4 mr-2" />
      View Content
    </Button>
  ) : null;

  const triggerElement = trigger || defaultTrigger;

  if (!triggerElement) {
    return null;
  }

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {triggerElement}
      </DialogTrigger>
      <DialogContent className={`${className} p-0 gap-0`} hideCloseButton={false}>
        <DialogHeader className="px-6 py-4 border-b">
          <DialogTitle className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <span className="text-lg font-semibold">
                Inscription #{inscriptionNumber || 'N/A'}
              </span>
              {analysis && (
                <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400">
                  <span className="px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded text-xs">
                    {analysis.contentInfo.detectedType}
                  </span>
                  <span className="text-xs font-mono">
                    {analysis.contentInfo.mimeType}
                  </span>
                </div>
              )}
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setOpen(false)}
              className="h-6 w-6 p-0"
            >
              <X className="h-4 w-4" />
            </Button>
          </DialogTitle>
        </DialogHeader>
        
        <div className="flex-1 p-6">
          <div className="flex justify-center">
            <InscriptionRenderer
              inscriptionId={inscriptionId}
              inscriptionNumber={inscriptionNumber}
              contentUrl={contentUrl}
              contentType={contentType}
              size={size}
              showHeader={false}
              showControls={true}
              autoLoad={true}
              onAnalysisComplete={handleAnalysisComplete}
            />
          </div>
          
          {analysis && (
            <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
              <h4 className="text-sm font-medium mb-2">Content Details</h4>
              <div className="grid grid-cols-2 gap-4 text-xs">
                <div>
                  <span className="text-gray-600 dark:text-gray-400">Type:</span>
                  <span className="ml-2 font-mono">{analysis.contentInfo.detectedType}</span>
                </div>
                <div>
                  <span className="text-gray-600 dark:text-gray-400">MIME:</span>
                  <span className="ml-2 font-mono">{analysis.contentInfo.mimeType}</span>
                </div>
                <div>
                  <span className="text-gray-600 dark:text-gray-400">Strategy:</span>
                  <span className="ml-2 font-mono">{analysis.contentInfo.renderStrategy}</span>
                </div>
                <div>
                  <span className="text-gray-600 dark:text-gray-400">Extension:</span>
                  <span className="ml-2 font-mono">{analysis.contentInfo.fileExtension || 'unknown'}</span>
                </div>
                {analysis.contentInfo.encoding && (
                  <div>
                    <span className="text-gray-600 dark:text-gray-400">Encoding:</span>
                    <span className="ml-2 font-mono">{analysis.contentInfo.encoding}</span>
                  </div>
                )}
                <div>
                  <span className="text-gray-600 dark:text-gray-400">Inline:</span>
                  <span className="ml-2">{analysis.contentInfo.isInlineable ? '‚úÖ' : '‚ùå'}</span>
                </div>
              </div>
              {analysis.preview && (
                <div className="mt-3">
                  <span className="text-gray-600 dark:text-gray-400 text-xs">Preview:</span>
                  <pre className="mt-1 p-2 bg-white dark:bg-gray-900 rounded text-xs font-mono overflow-hidden">
                    {analysis.preview}
                  </pre>
                </div>
              )}
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
};

// =================== LAZY INSCRIPTION CARD ===================

const LazyInscriptionCard: React.FC<{
  inscriptionId: string;
  inscriptionNumber?: number | string;
  contentUrl?: string;
  contentType?: string;
  size?: number;
  className?: string;
  showHeader?: boolean;
  showControls?: boolean;
  threshold?: number;
}> = ({
  inscriptionId,
  inscriptionNumber,
  contentUrl,
  contentType,
  size = 300,
  className = '',
  showHeader = true,
  showControls = true,
  threshold = 100
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [shouldLoad, setShouldLoad] = useState(false);
  const elementRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          // Add a small delay before loading to avoid loading too many at once
          const timer = setTimeout(() => {
            setShouldLoad(true);
          }, Math.random() * 500); // Random delay up to 500ms
          
          return () => clearTimeout(timer);
        }
      },
      {
        rootMargin: `${threshold}px`,
        threshold: 0.1
      }
    );

    if (elementRef.current) {
      observer.observe(elementRef.current);
    }

    return () => {
      if (elementRef.current) {
        observer.unobserve(elementRef.current);
      }
    };
  }, [threshold]);

  return (
    <div ref={elementRef} className={className}>
      {isVisible && shouldLoad ? (
        <InscriptionRenderer
          inscriptionId={inscriptionId}
          inscriptionNumber={inscriptionNumber}
          contentUrl={contentUrl}
          contentType={contentType}
          size={size}
          showHeader={showHeader}
          showControls={showControls}
          autoLoad={true}
        />
      ) : (
        <div 
          className="border rounded-lg shadow-sm bg-gray-100 overflow-hidden flex items-center justify-center"
          style={{ width: size, height: size }}
        >
          <div className="text-center text-gray-500">
            <div className="text-2xl mb-2">‚è≥</div>
            <div className="text-sm">Loading...</div>
            <div className="text-xs mt-1">#{inscriptionNumber || 'N/A'}</div>
          </div>
        </div>
      )}
    </div>
  );
};

// =================== MAIN INSCRIPTION VIEWER COMPONENT ===================

interface InscriptionViewerProps {
  inscriptions: InscriptionData[] | InscriptionData;
  cardSize?: number;
  className?: string;
  showHeaders?: boolean;
  showControls?: boolean;
  autoLoad?: boolean;
  gridCols?: 1 | 2 | 3 | 4 | 5 | 6;
  gap?: number;
  lazy?: boolean;
  enableModal?: boolean;
}

const InscriptionViewer: React.FC<InscriptionViewerProps> = ({
  inscriptions,
  cardSize = 300,
  className = '',
  showHeaders = true,
  showControls = true,
  autoLoad = true,
  gridCols = 3,
  gap = 16,
  lazy = false,
  enableModal = false
}) => {
  const inscriptionList = Array.isArray(inscriptions) ? inscriptions : [inscriptions];
  
  const getGridClassName = () => {
    const baseClasses = 'grid gap-4';
    const colClasses = {
      1: 'grid-cols-1',
      2: 'grid-cols-1 sm:grid-cols-2',
      3: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3',
      4: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4',
      5: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5',
      6: 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6'
    };
    return `${baseClasses} ${colClasses[gridCols]}`;
  };
  
  return (
    <div className={`w-full ${className}`}>
      <div 
        className={getGridClassName()}
        style={{ gap: `${gap}px` }}
      >
        {inscriptionList.map((inscription, index) => {
          const CardComponent = lazy ? LazyInscriptionCard : InscriptionRenderer;
          
          const cardElement = (
            <CardComponent
              key={inscription.id || index}
              inscriptionId={inscription.id}
              inscriptionNumber={inscription.number}
              contentUrl={inscription.contentUrl}
              contentType={inscription.contentType}
              size={cardSize}
              showHeader={showHeaders}
              showControls={showControls}
              autoLoad={autoLoad}
              className="mx-auto"
            />
          );

          if (enableModal) {
            return (
              <div key={inscription.id || index} className="flex justify-center">
                <InscriptionModal
                  inscriptionId={inscription.id}
                  inscriptionNumber={inscription.number}
                  contentUrl={inscription.contentUrl}
                  contentType={inscription.contentType}
                  trigger={cardElement}
                  modalSize="lg"
                  showTriggerButton={false}
                />
              </div>
            );
          }

          return (
            <div key={inscription.id || index} className="flex justify-center">
              {cardElement}
            </div>
          );
        })}
      </div>
    </div>
  );
};

// =================== DEMO COMPONENT ===================

const InscriptionViewerDemo: React.FC = () => {
  const [inputValue, setInputValue] = useState('');
  const [inscriptions, setInscriptions] = useState<InscriptionData[]>([]);
  const [viewMode, setViewMode] = useState<'single' | 'grid'>('single');
  const [cardSize, setCardSize] = useState(300);
  const [gridCols, setGridCols] = useState<1 | 2 | 3 | 4 | 5 | 6>(3);
  const [enableLazy, setEnableLazy] = useState(false);
  const [enableModal, setEnableModal] = useState(false);
  const [showHeaders, setShowHeaders] = useState(true);
  const [showControls, setShowControls] = useState(true);

  const handleAddInscription = () => {
    const ids = inputValue
      .split(/[,\n]/)
      .map(id => id.trim())
      .filter(id => id.length > 0);

    const newInscriptions = ids.map((id, index) => ({
      id,
      number: id.includes('i') ? id.split('i')[0] : id
    }));

    setInscriptions(newInscriptions);
  };

  const sampleInscriptions = [
    { id: '6fb976ab49dcec017f1e201e84395983204ae1a7c2abf7ced0a85d692e442799i0', number: '0' },
    { id: '26482871f33f1051f450f2da9af275794c0b5f1c61ebf35e4467fb42c2813403i0', number: '1' },
    { id: 'f2d90f5e4f7d9e3b8c5a1d7e9f6a2b5c8e1f4a7b0d3e6f9c2a5b8e1f4a7b0d3e6i0', number: '2' },
    { id: 'a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890i0', number: '3' },
    { id: 'b2c3d4e5f6789012345678901234567890123456789012345678901234567890a1i0', number: '4' },
    { id: 'c3d4e5f6789012345678901234567890123456789012345678901234567890a1b2i0', number: '5' }
  ];

  return (
    <div className="p-6 max-w-7xl mx-auto">
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-4">Bitcoin Inscription Viewer Library</h1>
        <p className="text-gray-600 mb-6">
          A complete React library for displaying Bitcoin inscriptions with smart content-type detection, 
          advanced renderers, lazy loading, and modal support.
        </p>

        {/* Main Controls */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2">View Mode</label>
              <div className="flex gap-2">
                <Button 
                  variant={viewMode === 'single' ? 'default' : 'outline'}
                  onClick={() => {
                    setViewMode('single');
                    setGridCols(1);
                  }}
                  size="sm"
                >
                  Single
                </Button>
                <Button 
                  variant={viewMode === 'grid' ? 'default' : 'outline'}
                  onClick={() => {
                    setViewMode('grid');
                    setGridCols(3);
                  }}
                  size="sm"
                >
                  Grid
                </Button>
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">Card Size: {cardSize}px</label>
              <input
                type="range"
                min="200"
                max="500"
                step="50"
                value={cardSize}
                onChange={(e) => setCardSize(parseInt(e.target.value))}
                className="w-full"
              />
            </div>

            {viewMode === 'grid' && (
              <div>
                <label className="block text-sm font-medium mb-2">Grid Columns: {gridCols}</label>
                <input
                  type="range"
                  min="1"
                  max="6"
                  step="1"
                  value={gridCols}
                  onChange={(e) => setGridCols(parseInt(e.target.value) as 1 | 2 | 3 | 4 | 5 | 6)}
                  className="w-full"
                />
              </div>
            )}
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2">Features</label>
              <div className="space-y-2">
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={enableLazy}
                    onChange={(e) => setEnableLazy(e.target.checked)}
                    className="mr-2"
                  />
                  <span className="text-sm">Lazy Loading</span>
                </label>
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={enableModal}
                    onChange={(e) => setEnableModal(e.target.checked)}
                    className="mr-2"
                  />
                  <span className="text-sm">Modal View</span>
                </label>
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={showHeaders}
                    onChange={(e) => setShowHeaders(e.target.checked)}
                    className="mr-2"
                  />
                  <span className="text-sm">Show Headers</span>
                </label>
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={showControls}
                    onChange={(e) => setShowControls(e.target.checked)}
                    className="mr-2"
                  />
                  <span className="text-sm">Show Controls</span>
                </label>
              </div>
            </div>

            <div className="text-xs text-gray-500 bg-gray-50 p-3 rounded">
              <div><strong>Cache Status:</strong> {inscriptionContentCache.size()} items cached</div>
              <div><strong>Features:</strong> Text, Images, Videos, Audio, JSON, HTML, 3D Models</div>
            </div>
          </div>
        </div>

        {/* Input Section */}
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Inscription IDs</label>
            <textarea
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              placeholder="Enter inscription IDs (one per line or comma-separated)..."
              className="w-full p-3 border rounded-md h-24 text-sm font-mono"
            />
          </div>
          <div className="flex gap-2 flex-wrap">
            <Button onClick={handleAddInscription}>
              Load Inscriptions
            </Button>
            <Button 
              variant="outline" 
              onClick={() => setInscriptions(sampleInscriptions)}
            >
              Load Sample Set
            </Button>
            <Button 
              variant="outline" 
              onClick={() => setInscriptions([])}
            >
              Clear All
            </Button>
            <Button 
              variant="outline" 
              onClick={() => inscriptionContentCache.clear()}
            >
              Clear Cache
            </Button>
          </div>
        </div>
      </div>

      {/* Results */}
      {inscriptions.length > 0 && (
        <div className="mb-8">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-semibold">
              Inscriptions ({inscriptions.length})
            </h2>
            <div className="text-sm text-gray-500">
              {enableLazy ? 'Lazy Loading Enabled' : 'Eager Loading'} ‚Ä¢ 
              {enableModal ? ' Modal Enabled' : ' Direct View'} ‚Ä¢ 
              {cardSize}px Cards
            </div>
          </div>
          
          <InscriptionViewer
            inscriptions={inscriptions}
            cardSize={cardSize}
            showHeaders={showHeaders}
            showControls={showControls}
            autoLoad={true}
            gridCols={gridCols}
            gap={16}
            lazy={enableLazy}
            enableModal={enableModal}
          />
        </div>
      )}

      {/* Documentation */}
      <div className="mt-12 space-y-8">
        <div className="p-6 bg-gray-50 rounded-lg">
          <h3 className="text-lg font-semibold mb-4">üìö Library Features</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
            <div>
              <h4 className="font-medium mb-2">üé® Content Types</h4>
              <ul className="space-y-1 text-gray-600">
                <li>‚Ä¢ Text & Code (with syntax highlighting)</li>
                <li>‚Ä¢ Images (PNG, JPG, GIF, SVG, WebP)</li>
                <li>‚Ä¢ Videos (MP4, WebM, AVI) with controls</li>
                <li>‚Ä¢ Audio (MP3, WAV, OGG) with player</li>
                <li>‚Ä¢ JSON (with collapsible tree view)</li>
                <li>‚Ä¢ HTML (sandboxed with source toggle)</li>
                <li>‚Ä¢ 3D Models (OBJ, STL, GLTF)</li>
                <li>‚Ä¢ Binary/Unknown (iframe fallback)</li>
              </ul>
            </div>
            <div>
              <h4 className="font-medium mb-2">‚ö° Advanced Features</h4>
              <ul className="space-y-1 text-gray-600">
                <li>‚Ä¢ Smart content-type detection</li>
                <li>‚Ä¢ Intelligent caching system</li>
                <li>‚Ä¢ Lazy loading with intersection observer</li>
                <li>‚Ä¢ Modal popups for detailed viewing</li>
                <li>‚Ä¢ Responsive grid layouts (1-6 columns)</li>
                <li>‚Ä¢ Download capabilities for all types</li>
                <li>‚Ä¢ Zoom, rotation, fullscreen controls</li>
                <li>‚Ä¢ Error handling with retry logic</li>
              </ul>
            </div>
          </div>
        </div>

        <div className="p-6 bg-gray-50 rounded-lg">
          <h3 className="text-lg font-semibold mb-4">üíª Usage Example</h3>
          <pre className="text-sm bg-white p-4 rounded border overflow-x-auto">
{`import { InscriptionViewer, InscriptionModal, LazyInscriptionCard } from './InscriptionViewer';

// Basic usage
<InscriptionViewer
  inscriptions={[
    { id: 'inscription-id-1', number: '1' },
    { id: 'inscription-id-2', number: '2' }
  ]}
  cardSize={300}
  gridCols={3}
  showHeaders={true}
  showControls={true}
  lazy={true}
  enableModal={true}
/>

// Advanced configuration
<InscriptionViewer
  inscriptions={inscriptionArray}
  cardSize={400}
  gridCols={4}
  gap={20}
  lazy={true}
  enableModal={true}
  showHeaders={true}
  showControls={true}
  className="my-custom-class"
/>

// Modal usage
<InscriptionModal
  inscriptionId="inscription-id"
  inscriptionNumber="123"
  modalSize="xl"
  trigger={<button>View Inscription</button>}
/>

// Lazy card usage
<LazyInscriptionCard
  inscriptionId="inscription-id"
  inscriptionNumber="123"
  size={300}
  threshold={100}
/>`}
          </pre>
        </div>

        <div className="p-6 bg-blue-50 rounded-lg">
          <h3 className="text-lg font-semibold mb-4">üöÄ Ready for Production</h3>
          <p className="text-sm text-gray-700 mb-4">
            This library is now 100% complete with all advanced features implemented:
          </p>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
            <div>
              <strong>‚úÖ Core Components</strong>
              <ul className="mt-1 space-y-1 text-gray-600">
                <li>‚Ä¢ InscriptionViewer</li>
                <li>‚Ä¢ InscriptionRenderer</li>
                <li>‚Ä¢ InscriptionModal</li>
                <li>‚Ä¢ LazyInscriptionCard</li>
              </ul>
            </div>
            <div>
              <strong>‚úÖ Specialized Renderers</strong>
              <ul className="mt-1 space-y-1 text-gray-600">
                <li>‚Ä¢ TextRenderer</li>
                <li>‚Ä¢ ImageRenderer</li>
                <li>‚Ä¢ VideoRenderer</li>
                <li>‚Ä¢ AudioRenderer</li>
                <li>‚Ä¢ JsonRenderer</li>
                <li>‚Ä¢ HtmlRenderer</li>
                <li>‚Ä¢ ThreeDRenderer</li>
                <li>‚Ä¢ IframeRenderer</li>
              </ul>
            </div>
            <div>
              <strong>‚úÖ Production Ready</strong>
              <ul className="mt-1 space-y-1 text-gray-600">
                <li>‚Ä¢ TypeScript definitions</li>
                <li>‚Ä¢ Error boundaries</li>
                <li>‚Ä¢ Performance optimized</li>
                <li>‚Ä¢ Fully responsive</li>
                <li>‚Ä¢ Accessibility support</li>
                <li>‚Ä¢ Dark mode ready</li>
                <li>‚Ä¢ NPM package ready</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// =================== EXPORTS ===================

export default InscriptionViewerDemo;
export { 
  InscriptionViewer, 
  InscriptionRenderer, 
  InscriptionModal,
  LazyInscriptionCard,
  TextRenderer,
  ImageRenderer,
  VideoRenderer,
  AudioRenderer,
  JsonRenderer,
  HtmlRenderer,
  ThreeDRenderer,
  IframeRenderer,
  analyzeContent,
  shouldLazyLoad,
  inscriptionContentCache
};